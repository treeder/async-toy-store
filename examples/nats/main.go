package main

import (
	"encoding/json"
	"fmt"
	"log"
	"sync"

	nats "github.com/nats-io/nats.go"
)

// Order ...
// todo: this struct and the nats code in main() should be generated by AsyncAPI
type Order struct {
	ID     string  `json:"id"`
	Amount float64 `json:"amount"`
}

func main() {
	c, err := nats.Connect("nats://localhost:4222")
	if err != nil {
		log.Fatal(err)
	}
	defer c.Close()

	channel := "orders"
	numMessages := 10

	var wg sync.WaitGroup

	// First subscribe, so we get any publishes messages
	_, err = c.Subscribe(channel, func(m *nats.Msg) {
		order := &Order{}
		err := json.Unmarshal(m.Data, order)
		if err != nil {
			fmt.Printf("Unmarshal error: %v\n", err)
			// todo: be nice to have a way for user to deal with errors
			return
		}
		fmt.Printf("got order: %+v\n", order)
		wg.Done()
	})
	if err != nil {
		log.Fatal(err)
	}

	// Now we publish. This would usually be in a separate program for subscribe.
	for i := 0; i < numMessages; i++ {
		order := &Order{ID: fmt.Sprintf("%v", i+1), Amount: 101.01}
		b, err := json.Marshal(order)
		if err != nil {
			log.Fatal(err)
		}
		if err := c.Publish(channel, b); err != nil {
			log.Fatal(err)
		}
		wg.Add(1)
	}
	// Make sure the message goes through before we close
	c.Flush()

	wg.Wait()
}
